#ifndef OUTPUT_OLED
    #error TODO
#endif

#define TERNARY(c,t,f) do if c then escape t; else escape f; end end;
#define _pow2(v) ((v*v) as real)

native/pos do
    ##include <math.h>
end

data Data with
    var    u16  touches = 0;
    var    u32  vel     = 0;
    var    real vol     = 0;
    var    real pot     = 0;
    var[3] u32  equ     = [ 0, 0, 0 ];
    var[3] u16  tch     = [ 0, 0, 0 ];
end

var Data loc = _;
var Data glb = _;

var real g_equ = 0;
var u32  g_dt  = 0;
var u32  dt    = 0;

var u16  seq   = 0;

par do
    every out_game_ini do
        _oled.clear();
        _oled.print(_F("Inicio do Jogo!"));
    end
with
    var u16 seqs;
    every seqs in out_game_end do
        _oled.clear();
        _oled.print(_F("Fim do Jogo!"));
        _oled.setCursor(0,3);
        _oled.print(seqs);
        _oled.print(_F(" sequencia(s)"));
    end
with
    every out_sequence_ini do
        loc.touches = 0;
        loc.vel     = 0;
        loc.vol     = 0;
        loc.pot     = 0;

        loc.equ[0]  = 0;
        loc.equ[1]  = 0;
        loc.tch[0]  = 0;
        loc.tch[1]  = 0;

        dt = 0;

        seq = seq + 1;
    end
with
    //var u16 seq;
    var u32 ms;
    every (_,ms) in out_sequence_end do
        var real equ0 = TERNARY((loc.tch[0]==0), 9999, ((loc.equ[0] as real)/(loc.tch[0] as real)));
        var real equ1 = TERNARY((loc.tch[1]==0), 9999, ((loc.equ[1] as real)/(loc.tch[1] as real)));
        var real equ  = _sqrt((_pow2(equ0) + _pow2(equ1)) / 2);
        //g_equ = g_equ + _ms2pts(equ) * ms;
        g_dt  = g_dt + ms;
        _ceu_dbg_assert(dt == ms);
    end
with
    //var u16  touch;
    var u8   id;
    var u32  ms;
    //var bool is_att;
    every (_,id,ms,_) in out_touch do

        loc.touches = loc.touches + 1;
        loc.vel     = loc.vel     + ms;
        loc.vol     = loc.vol     + _pow2(ms);
        loc.pot     = loc.pot     + _sqrt(ms);
        glb.touches = glb.touches + 1;
        glb.vel     = glb.vel     + ms;
        glb.vol     = glb.vol     + _pow2(ms);
        glb.pot     = glb.pot     + _sqrt(ms);

        loc.equ[id] = loc.equ[id] + ms;
        loc.tch[id] = loc.tch[id] + 1;
        glb.equ[id] = glb.equ[id] + ms;
        glb.tch[id] = glb.tch[id] + 1;

        //var real g_equ_;
        dt = dt + ms;

        if id == 1 then
            _oled.setCursor(0,2);
        else
            _oled.setCursor(95,2);
        end
        _oled.print(ms);
        _oled.print(_F("  "));

        do
            var real vel =       (loc.vel as real) / (loc.touches as real);
            var real vol = _sqrt((loc.vol as real) / (loc.touches as real));
            var real pot = _pow2((loc.pot as real) / (loc.touches as real));

            var real equ0 = TERNARY((loc.tch[0]==0), 9999, (loc.equ[0] as real)/(loc.tch[0] as real));
            var real equ1 = TERNARY((loc.tch[1]==0), 9999, (loc.equ[1] as real)/(loc.tch[1] as real));
            var real equ  = _sqrt((_pow2(equ0) + _pow2(equ1)) / 2);

            //g_equ_ = (g_equ + _ms2pts(equ)*dt) / ((g_dt + dt) as real);

            _oled.setCursor(0,3);
            _oled.println(vel);
            _oled.println(vol);
            _oled.println(pot);
            _oled.println(equ);
        end

        do
            var real vel =       (glb.vel as real) / (glb.touches as real);
            var real vol = _sqrt((glb.vol as real) / (glb.touches as real));
            var real pot = _pow2((glb.pot as real) / (glb.touches as real));

            var real equ0 = TERNARY((glb.tch[0]==0), 9999, (glb.equ[0] as real)/(glb.tch[0] as real));
            var real equ1 = TERNARY((glb.tch[1]==0), 9999, (glb.equ[1] as real)/(glb.tch[1] as real));
            var real equ  = _sqrt((_pow2(equ0) + _pow2(equ1)) / 2);

            var u16 falls = seq - 1 + 1; // assume an imminent fall
            falls = _ceil(((falls*MS_TO_GAME) as real) / ((g_dt+dt) as real));

            _oled.setCursor(95,3);
            _oled.println(vel);
            _oled.println(vol);
            _oled.println(pot);
            _oled.println(equ);
#if 0
           (u16)g_equ_, falls+1);
#endif
        end
    end
end
