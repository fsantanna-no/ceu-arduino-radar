native _radio;
native/nohold _radio_read, _radio_write;
native/pos do
    ##include <SPI.h>
    ##include <nRF24L01.h>
    ##include <RF24.h>
    ##define radio_read(a,b) radio.read(a,b)
    ##define radio_write(a,b) radio.write(a,b)
    const uint64_t pipe =  0xE8E8F0F0E1LL;
    RF24 radio(8,7);

    tceu_callback_ret CB_INPUT_F (int cmd, tceu_callback_arg p1, tceu_callback_arg p2, const char* file, u32 line) {
        tceu_callback_ret ret = { .is_handled=0 };
        if (cmd != CEU_CALLBACK_OUTPUT) {
            return ret;
        }
        switch (p1.num) {
            case CEU_OUTPUT_GET_TIME:
                *(*((u32**)p2.ptr)) = millis();
                ret.is_handled = 1;
                break;
        }
        return ret;
    }
    tceu_callback CB_INPUT = { &CB_INPUT_F, NULL };
end

{
    ceu_callback_register(&CB_INPUT);
    radio.begin();
    //radio.setAutoAck(false);              // true by default
    radio.setDataRate(RF24_250KBPS);
    //radio.setDataRate(RF24_1MBPS);
    radio.openWritingPipe(pipe);
    radio.openReadingPipe(1,pipe);
    radio.startListening();
}

spawn do
    par do
        await async do
            loop do
                if _radio.available() as bool then
                    var u8 v = _;
                    _radio_read(&&v, 1);
                    var u8   id      = (v & 0xF);
                    var bool is_fore = (v >> 4)  as bool;
                    //{Serial.print("id: ");  Serial.print(@id);}
                    //{Serial.print("f/b: "); Serial.println(@is_fore);}
                    emit IN_TOUCH(id, is_fore);
                end
            end
        end
    with
        var byte v;
        every v in SERIAL do
            var byte id   = 0;
            var byte back = 0;
            var byte fore = 0;
            v = (id << 4) | (back << 1) | fore;
            _radio_write(&&v, 1);
        end
    end
end
