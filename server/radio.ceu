native _radio;
native/nohold _radio_read, _radio_write;
native/pos do
    ##include <SPI.h>
    ##include <nRF24L01.h>
    ##include <RF24.h>
    ##define radio_read(a,b) radio.read(a,b)
    ##define radio_write(a,b) { radio.stopListening(); for (int i=0; i<1; i++) { radio.write(a,b); } radio.startListening(); }
    const uint64_t pipe =  0xAABBCCDDEELL;
    RF24 radio(8,7);

    tceu_callback_ret CB_INPUT_F (int cmd, tceu_callback_arg p1, tceu_callback_arg p2, const char* file, u32 line) {
        tceu_callback_ret ret = { .is_handled=0 };
        if (cmd != CEU_CALLBACK_OUTPUT) {
            return ret;
        }
        switch (p1.num) {
            case CEU_OUTPUT_GET_TIME:
                *(*((u32**)p2.ptr)) = millis();
                ret.is_handled = 1;
                break;
        }
        return ret;
    }
    tceu_callback CB_INPUT = { &CB_INPUT_F, NULL };
end

{
    ceu_callback_register(&CB_INPUT);
    radio.begin();
    radio.setAutoAck(false);              // true by default
    radio.setDataRate(RF24_1MBPS);
    radio.openReadingPipe(1,pipe);
    radio.startListening();
    radio.openWritingPipe(pipe);
}

spawn do
    loop do
        if _radio.available() as bool then
            await async do
                var u8 v = _;
                _radio_read(&&v, 1);
                var u8   id      = (v & 0xF);
                var bool is_fore = (v >> 4)  as bool;
#if 0
                {
                    Serial.print("id: ");  Serial.print(@id);
                    Serial.print(" ");
                    Serial.print("f/b: "); Serial.println(@is_fore);
                }
#endif
                emit IN_TOUCH(id, is_fore);
            end
            //await 200ms;    // skip storm
        else
            await async do end;
        end
    end
end
