#define OUTPUT_OLED

#if 0
TX      Bluetooth
RX      Bluetooth
D2      Sound
D3      Botao OK
D4      Botao PLUS
D5      Botao MINUS
D6
D7      Radio
D8      Radio
D9
D10
D11     Radio
D12     Radio
D13     Radio
A0      Sensor
A1      Sensor
A2
A3
A4
A5      OLED
A6      OLED
#endif

//#define DEBUG
#include "c.ceu"
#include "arduino/arduino.ceu"

#if 0
    - desconsiderar o último par (últimos 2 toques) para
        - contar somente ataques com continuidade (foi e voltou)
            - evitar porrada na última bola
        - incentivar salvamentos, se não der certo (cair em seguida), não conta pra média
#endif

//#define MS_TO_GAME              10000           // 10 seconds
#define MS_TO_GAME              30000           // 30 seconds
//#define MS_TO_GAME              {300000LL}      // 5 minutes
#define MS_TO_FALL              3000            // 3 seconds
#define DISTANCE_IN_CM          800             // 8 meters
#define ATTACK_THRESHOLD_IN_MS  500             // 0.5s
#define RULE_20

input  (u8,bool)         IN_TOUCH;
input  int               IN_CONFIG;

output &u32              GET_TIME;

output (u8,u8)           OUT_GAME_INI;          // idA, idB
output u16               OUT_GAME_END;          // #seqs
output u16               OUT_SEQUENCE_INI;      // seq
output (u16,u32)         OUT_SEQUENCE_END;      // seq, dt
output u16               OUT_SEQUENCE_FALL;     // seq
output (u16,u8,u32,bool) OUT_TOUCH;             // touch, id, dt

input byte SERIAL_RECEIVE_BYTE;

#ifdef OUTPUT_OLED
#if 1
native _oled;
native/pre do
    ##include "SSD1306Ascii.h"
    ##include "SSD1306AsciiAvrI2c.h"
    SSD1306AsciiAvrI2c oled;
end
{
    oled.begin(&Adafruit128x64, 0x3C);
    oled.setFont(font8x8);
}
#else
native _display;
native/pre do
    ##include <SPI.h>
    ##include <Wire.h>
    ##include <Adafruit_GFX.h>
    ##include <Adafruit_SSD1306.h>
    ##define OLED_RESET 4
    Adafruit_SSD1306 display(OLED_RESET);
    ##if (SSD1306_LCDHEIGHT != 64)
    ##error("Height incorrect, please fix Adafruit_SSD1306.h!");
    ##endif
end
{
    display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
}
#endif
#endif

_Serial.println("ok");
_delay(1000);

#define PIN_TONE 2
output bool PIN_02;

#define BUT_OK    PIN_03
#define BUT_PLUS  PIN_04
#define BUT_MINUS PIN_05
input on/off BUT_OK;
input on/off BUT_PLUS;
input on/off BUT_MINUS;

#ifdef DEBUG
#include "tests.ceu"
#else
#include "tone.ceu"
#include "input.ceu"
do
    #include "config.ceu"
end
#endif

par do
    //#include "abraf.ceu"
    await FOREVER;
with
    //#include "chico.ceu"
    await FOREVER;
with
    //#include "media.ceu"
    await FOREVER;
with
    //#include "debug.ceu"
    await FOREVER;
with
    loop do
        var u8 idA;
        var u8 idB;
        (idA,_) = await IN_TOUCH;
        (idB,_) = await IN_TOUCH until (idA != idB);
        _ceu_dbg_assert(idA+idB == 1);

        emit OUT_GAME_INI(idA,idB);
        spawn Tone_Start;
        await 500ms;                                    // skip storm

        var u32 ms_game = 0;                            // total game time

        pool[2] Tone tones;

        var u16 seq;
        loop seq in [1 -> _[ do
            var[2*] u32 ms;
            var u32 ms_0 = _;

            emit OUT_SEQUENCE_INI(seq);
            do finalize with
                var u32 dt = do
                    if $ms >= 2 then
                        escape ms[$ms-1] - ms_0;        // ms difference between last and 0th touch
                    else
                        escape 0;
                    end
                end;
                emit OUT_SEQUENCE_END(seq,dt);
            end

            var u8 id1;
            (id1,_) = await IN_TOUCH;                // start counting after 0th touch
            //emit OUT_TOUCH(0, id1, -1);
            spawn Tone_Ball in tones;

            do
                var u32 now = _;
                emit GET_TIME(&now);
                ms = ms .. [now];
                ms_0 = now;
            end

#ifdef RULE_20
            var u32? old;
#endif
            var u16 touch;
            loop touch in [1 -> _[ do                   // TRACK TOUCHES
                par/or do                               // track fall
                    await (MS_TO_FALL)ms;
                    break;
                with                                    // alternate touches between idA/idB
                    var u8 id2;
                    var bool is_fore;
                    (id2,is_fore) = await IN_TOUCH until (id2 != id1);
                    do
                        var u32 now = _;
                        emit GET_TIME(&now);
                        if $ms == $$ms then
                            $ms = $ms - 1;
                        end
                        ms = ms .. [now];
                    end
                    var u32 dt = ms[$ms-1]-ms[$ms-2];
                    var bool is_att = do
#ifdef RULE_20
                        var bool ret = (touch > 1) and (dt <= (old! as real)*0.8);
                        old = dt;
                        escape ret;
#else
                        escape (dt <= ATTACK_THRESHOLD_IN_MS);
#endif
                    end;

                    emit OUT_TOUCH(touch, id1, dt, is_att);
                    if is_fore then
                        if is_att then
                            spawn Tone_Fore_Attack in tones;
                        else
                            spawn Tone_Fore in tones;
                        end
                    else
                        if is_att then
                            spawn Tone_Back_Attack in tones;
                        else
                            spawn Tone_Back in tones;
                        end
                    end
                    id1 = id2;

                    ms_game = ms_game + dt;
                    if ms_game >= MS_TO_GAME then       // CHECK TOTAL GAME TIME
                        break/seq;
                    end
                end
            end

            emit OUT_SEQUENCE_FALL(seq);
            spawn Tone_Fall in tones;
        end

        emit OUT_GAME_END(seq);
        spawn Tone_End in tones;
        await 5s;
    end
end
