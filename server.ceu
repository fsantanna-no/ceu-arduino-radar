#include "c.ceu"

#if 0
    - desconsiderar o último par (últimos 2 toques) para
        - contar somente ataques com continuidade (foi e voltou)
            - evitar porrada na última bola
        - incentivar salvamentos, se não der certo (cair em seguida), não conta pra média
#endif

#define MS_TO_GAME              {30000LL}      // 5 minutes
#define MS_TO_FALL              3000            // 3 seconds
#define DISTANCE_IN_CM          800             // 8 meters
#define ATTACK_THRESHOLD_IN_MS  500             // 0.5s

input  u8            IN_TOUCH;

output &u32          GET_TIME;

output (u8,u8)       OUT_GAME_INI;          // idA, idB
output u16           OUT_GAME_END;          // #seqs
output u16           OUT_SEQUENCE_INI;      // seq
output (u16,u32)     OUT_SEQUENCE_END;      // seq, dt
output u16           OUT_SEQUENCE_FALL;     // seq
output (u16,u8,u32)  OUT_TOUCH;             // touch, id, dt

input byte SERIAL;

par/or do
    //#include "abraf.ceu"
    await FOREVER;
with
    #include "media.ceu"
    await FOREVER;
with
    //#include "debug.ceu"
    await FOREVER;
with
    #if 0
        #include "tests.ceu"
    #else
        #include "input.ceu"
        await FOREVER;
    #endif
with
    loop do
        var u8 idA = await IN_TOUCH;
        var u8 idB = await IN_TOUCH until (idA != idB);

        emit OUT_GAME_INI(idA,idB);
        var u32 ms_game = 0;                            // total game time

        var u16 seq;
        loop seq in [1 -> _[ do
            var[2*] u32 ms;
            var u32 ms_0 = _;

            emit OUT_SEQUENCE_INI(seq);
            do finalize with
                var u32 dt = do
                    if $ms >= 2 then
                        escape ms[$ms-1] - ms_0;        // ms difference between last and 0th touch
                    else
                        escape 0;
                    end
                end;
                emit OUT_SEQUENCE_END(seq,dt);
                ms_game = ms_game + dt;
            end

            var u8 id1 = await IN_TOUCH;                // start counting after 0th touch
            _ceu_dbg_assert(id1==idA or id1==idB);

            do
                var u32 now = _;
                emit GET_TIME(&now);
                ms = ms .. [now];
                ms_0 = now;
                emit OUT_TOUCH(0, id1, -1);
            end

            par/or do                                   // TRACK TOTAL GAME TIME
                _ceu_dbg_assert(ms_game < MS_TO_GAME);
                await (MS_TO_GAME-ms_game+1)ms;           // time left
                break/seq;
            with                                        // TRACK TOUCHES
                var u16 touch;
                loop touch in [1 -> _[ do
                    par/or do                           // track fall
                        await (MS_TO_FALL)ms;
                        break;
                    with                                // alternate touches between idA/idB
                        var u8 id2 = await IN_TOUCH until (id2 != id1);
                        _ceu_dbg_assert(id1==idA or id1==idB);
                        do
                            var u32 now = _;
                            emit GET_TIME(&now);
                            ms = ms .. [now];
                        end
                        emit OUT_TOUCH(touch, id1, ms[$ms-1]-ms[$ms-2]);
                        id1 = id2;
                        $ms = $ms - 1;
                    end
                end
                emit OUT_SEQUENCE_FALL(seq);
            end
        end

        emit OUT_GAME_END(seq);
    end
end

escape 0;
