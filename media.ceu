native/pos do
    u16 M_IDA, M_IDB;
    int M_ATAS[65536];

    int M_TOTAL, M_PAR;

    tceu_callback_ret CB_MEDIA_F (int cmd, tceu_callback_arg p1, tceu_callback_arg p2, const char* file, u32 line) {
        tceu_callback_ret ret = { .is_handled=0 };
        if (cmd != CEU_CALLBACK_OUTPUT) {
            return ret;
        }
        switch (p1.num) {
            case CEU_OUTPUT_OUT_GAME_INI: {
                tceu_output_OUT_GAME_INI* ps = (tceu_output_OUT_GAME_INI*) p2.ptr;
                M_IDA = ps->_1;
                M_IDB = ps->_2;
                ceu_dbg_assert(M_IDA<65536 && M_IDB<65536);
                break;
            }
            case CEU_OUTPUT_OUT_SEQUENCE_INI: {
                printf("===============================================================\n");
                M_ATAS[M_IDA] = 0;
                M_ATAS[M_IDB] = 0;
                M_TOTAL = M_PAR = 0;
                break;
            }
            case CEU_OUTPUT_OUT_TOUCH: {
                tceu_output_OUT_TOUCH* ps = (tceu_output_OUT_TOUCH*) p2.ptr;
                int touch = ps->_1;
                u16 id = ps->_2;
                u16 ms = ps->_3;
                if (ms <= ATTACK_THRESHOLD_IN_MS) {
                    M_ATAS[id]++;
                }
                static int cur = 0;
                if (touch > 0) {
                    cur += ms;
                    if (touch%2 == 0) {
                        M_TOTAL += cur;
                        M_PAR++;
                        printf("> [%3d] MS/PAR: %4d atual | %4d acumulado || ATAS: %2d/%2d=>%3d\n",
                            touch, cur, M_TOTAL/M_PAR, M_ATAS[M_IDA], M_ATAS[M_IDB], M_ATAS[M_IDA]+M_ATAS[M_IDB]);
                        cur = 0;
                    }
                } else {
                    cur = 0;
                }
                break;
            }
        }
        return ret;
    }
    tceu_callback CB_MEDIA = { &CB_MEDIA_F, NULL };
end
{ ceu_callback_register(&CB_MEDIA); }
